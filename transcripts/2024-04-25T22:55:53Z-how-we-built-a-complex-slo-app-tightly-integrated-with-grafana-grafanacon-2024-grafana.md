# How We Built a Complex SLO App Tightly Integrated with Grafana | GrafanaCON 2024 | Grafana

One of our newest solutions in Grafana Cloud is an app that helps users create good SLOs and incorporate them into their ...

Published on 2024-04-25T22:55:53Z

URL: https://www.youtube.com/watch?v=hZdvcGztUts

Transcript: I'm Joe I'm I'm the tech lead for grafana SLO which is a grafana cloud application and I'm going to talk a little bit about how we built it um on top of our prototype for the grafana app platform so I'm going to expand a little bit on what Stephanie and Ryan talked about I walk you through what graphon SLO is sort of the functions of the app and the architecture we use for that uh the sort of operator architecture and how we use features of the app platform to make that work um so graphon SLO was installed in every graphon cloud stack uh which means we've got thousands of installations across dozens of clusters all over the world um and we built it with a team of three engineers and ux designer uh the team has grown a bit since then but that means the front end and the backend three engineers and ux designer and that meant that we kind of needed some help to do um a lot of underlying stuff right to make the team productive um and so I met with some people at graffo who pitched me on this concept of the app platform that could really save my team time um I'll talk a little bit about the app so SLO stands for service level objectives and service level objectives are this framework for how you can build a better software engineering culture uh at your company and basically what it asks you to do is to measure what your customers care about um which might be the latency and success rate of a checkout process in an e-commerce app it might be outputs from your meat free uh manufacturing process right it might be the quality of the output you're producing the quantity of the output you're producing might be whether your kid is keeping his room clean um and then it asks you to set a goal for that measurement and uh which might be like um checkouts succeed in less than one second 99.95% of the time right it's really important that your customers can give you money uh then you're going to compute whether you're meeting that goal over time and get alerted when you're in danger of not meeting that goal that helps you measure what's important respond when what's important is broken and you know not wake up at 3: a.m because the disc is 95% full who cares who cares if my customers can give me money um so that's what the SLO framework helps you do now there's a lot of little fiddly things involved in that there's a great blog post from SoundCloud about sort of this framework there's a whole book from Google about it but how many people in your company are going to read that whole book um as you get better at using slos you can use them for more than just measuring and alerting now you know how you've been doing over the last month two months three months and you can start to make plans you can adjust your team's Behavior based on how well you're doing um you can you right you can say I need to trade off Feature work for reliability work because I'm cutting it really close in terms of my objectives I'm trying to meet or even you know over the last month we had a horrible outage caused by XYZ and so we under performed what we expected to do um so you can adjust your behavior based on your past uh measurements so that's what our app does um it makes it easier for you to Define what's important for your application based on your metrics uh it handles the math of alerting computing whether you're meeting your objectives and it provides a bunch of um visualization so you don't need Graff dashboard experts to make this happen you don't need to be steeped in the math of computing whether I've met my SLO in the last minute hour 30 days when should an alert take place uh based on those problems so that takes some burden off your SRE team and let you give it to the application developers who ought to be monitoring and responding to problems um in their services so we want to make it easier to uh make all of that smoother for people um here's a view of one part of the app which is part of the creation workflow which um you know is basically let's let's not write a huge expression in explore or a big expression editor and then save it or write it in some yaml file that we put um as a rule in our in our promql or sorry in our Prometheus configuration um we guide you through um selecting right in this case uh no 500s um less than 500 milliseconds is the the sort of um definition here right you can see this in success method success metric on that thing um and then we guide you through setting up alerts you go through a review of what things are going on in this case the ASO is really loose 75% success rate um and then we generate dashboards and Metric recording rules and alerting rules um we highlight if there are any current alerts we tell you how you're doing over time and we generate um an overview dashboard for every SLO at your company so you can you know get a broad view um and we also provide drill down capabilities into these slos These are dimensioned it's not just one measurement across your whole company you can group them by your cluster that they're in you could group it by uh all sorts of Dimensions at graffo we tend to group by cluster because we tend to have geographically isolated kind of failures or Global kind of failures related to shipping a bug so that's a really useful um way that that we use the tool to dig into um where problems are happening so yeah great what's a dashboard what's an alerting rule a recording rule it's some it's some config right oh just generate some Json post it into post it into um a file put it put it somewhere that the Prometheus operator can pick up this all sounds you know fairly simple but things break all the time right um metrics database could be down when you're trying to Define an SLO do you want to stop everybody's work because of that dashboard apis might fail things just happen right somebody might uh somebody might restrict the folder you want to put the dashboard into to like the one person who's allowed to access it now that might not actually be what you want to happen so there's a lot of ways that simple things can fail right um and so we uh we want to do a lot of this work asynchronously in a way that can be retried and in a way that works reliably um uh another reason we want to do these sort of things asynchronously is um scale when you have a few hundred slos you want terraform apply every single one of them if you're synchronously like make me a dashboard it takes 500 milliseconds make me things get really slow as code tools get really sad so we like to decouple them and make them asynchronous um so a model that Stephanie and Ryan also talked about that works well in that case is this sort of call it an operator model call it a reconciler model which is um operators watch things and then they take actions and their goal is to put the real world and the desire you know and what's configured together right to bring the real world to match the configured State um the nice thing about this pattern is it decouples all of those API actions from all of the underlying work that might happen and there's a lot of different kinds of underlying work that you could program um but in in our case it's to create these two dependent resources a um alerting and recording configuration and a set of dashboards right it's not just a dashboard per SLO it's this uh summary dashboard that needs to exist and it's um it it also um is a good way of uh not only responding to user input but responding to code changes if we change what a dashboard should look like because the app has become more advanced we have new features we want to put that in things we have new alerting rule configurations all we have to do is ship a new version of the operator here the operator spins up it syncs and sees all of the current config it sees that the real world is different from what the new features of the app are and it makes those changes right so we don't have to you know so it's it's relatively simple for us to ship new features and then have then have them reconciled as well um so talk about what in the graphon Cloud app app platform which is our prototype uh that that we built that is now you know we're starting to implement the things we learned in grafana itself um what we use from that so I'm going to start with the schemas and code Generation stuff I'm gonna um then I'm going to talk about the storage service itself and the API associated with that validation that comes along with that and um what watching resources does for us so schemas um graph's SDK provides an awesome easy way to define a schema which is in this nice data validation language called Q um Capital C capital u capital e um what's nice about Q is it's super compact compared to a lot of other ways that schemas are defined except maybe protocol buffers it's one of the more compact schema definition uh languages I've looked at I want to highlight um you start with something simple like this you get a bunch of stuff out I want to highlight a couple things here which is that I'm asking for code for the front end and a backend process I have defined one version of my config object here which is V1 alpha 1 um in this spec you can Define multiple versions write in line in the same thing here give them all names and say which one should the storage service be using this makes it nice because you get Cod genen for all of those versions and that makes writing migration routines between them really easy right actually have everything typed there and so um I'm not writing some some kind of SQL update kind of thing that may or may not be typed and you know all those problems that we've all run into in the past so this is a pretty compact definition there's only two things in here there's two um optional Fields what alerting system should the SLO app use and um oh this is narrower than I thought sorry we're missing a little bit here um but basically what the recording rule policy should be we have ways of saving our customers money when they don't need some of the data and or giving them all of the rules um when they do so these are restricted string enumerations right alerting system can only have those two values after I run the code gen I get this open API V3 version of that definition it's a lot longer I'm really happy I don't have to type spec group versions name serve storage schema API you know this is mostly a convenience factor to get from to get from here to that you can see it has some of the same things right it's an enum with data source and grafana associated with it um you get some go code out of that I have some nice typed constants these are optional Fields because they're pointers I get even types for the different fields um again it's just stuff that makes it harder for me to fat finger something um I have fat fingers and we get some typescript which has a lot of similar features associated with so you can see we actually use language features in that code gen right like typescript will complain to me if I set if I set a wrong value here too so we use this in our front end as part of that you know Builder thing that I showed you before so we can't we can't screw it up there's a lot of ways we can't screw these things up that are provided by the app platform SDK that I really really um was happy about schemas are great I love schemas I love these schemas in particular because they've made it a lot easier for my small team to be productive um so we installed that schema in the storage system let's talk a little bit about the storage system um we don't have to run a database because of the storage system this was the the sweet thing that really sold me um on this aspect of the app platform I didn't want to run you know right we got dozens of clusters I didn't want to run dozens of my SQL databases and monitor them I have colleagues who have to do that for their plugins I'm really happy that I don't have to do that right there's a team that maintains the app platform if I ran grafana um now right if I use the current version of grafana that's starting to get these storage features in them I just have to monitor grafana right I've already got that kind of stuff set up um there's a one less thing that my team has to run which is really great and the app platform apis are really standardized uh this is this is like what's now Ryan and Stephanie showed you s of what's coming my structure is going to get a little more verbose here but it's going to look the same for every resource type which is really great um it's a key value store right you can you can fetch by a key that the that the platform generates or you can fetch by a label expression right you can put arbitrary text labels on any resource and then you can do a list by a label expression we use this for for a bunch of features in our UI um before if I was storing configuration for a plugin in a plugin I would use plugin in grafana I would use this um this thing called uh Json data right that every plug-in gets to write they can write this Json into the database and they can write some encrypted Json into the database that the back end can get safely that's great but if I want to write like 18 SLO objects and user preference objects and some limit object I just have this giant Json document that I have to fetch every time I want to look at one of those things or I write in my SQL database and now I have to run you know or write tables in my SQL I have to run it but 20 objects is not that much it's it's kind of feels awful to write a SQL database to hold 20 things so this is this is a a really great in between there to have hundreds of objects uh that I can fetch as I need and not you know what I might have done before to hack that into the plug-in platform um talk about data validation the app platform provides data validation capabilities out of the box this is that open API V3 thing I showed before string enums like data source and grafana the platform will actually execute validation Logic on every create update to make sure that it matches the spec of the open API schema so in this case I can't fat finger it and write graama the app platform will just reject that for me um you can also write I don't show them here but you can write more complex validation logic across multiple fields in an expression language um called cal It's really simple like guaranteed to terminate just predicate kind of language the system will execute that for you so I still haven't written anything that I have to run to validate my data this is nice I I we we use this right now um but we also uh run into more complex validation uh the SLO type itself has promql in it right I showed metrics before we're going to have sums and groupings and things like that so now I need to parse promql um I can't write that in C it's it's awful right it's an actual you know language so I need somewhere I can run the prom Q parser and so we use those hooks that that Stephanie mentioned these admission hooks um they get called by the app platform server I can put kind of anything I want as long as it doesn't take too long to run in there and I get like synchronous validation this is getting more complex I have to deploy some code somewhere um but the really nice thing about having the API server execute all that validation logic is I don't have some proxy somewhere executing it and I need to make sure I route all clients to that proxy right I can just go through the grafana API thing it can forward the the data back to the app platform server everything gets run against that terraform client there's no like going around it right some you somebody finds some way around that the validation logic always gets executed um and I'm excited I don't do this yet but I'm excited to try running these things on a function as a service platform right like M AWS Lambda because edits are bursty right they don't happen all the time they might happen every time you do a g commit every few hours days week whatever um so it's you know it would be great to be able to scale that to zero and that's certainly something you could you could do um in a in a scenario like that so I'm interested to try that but I haven't tried it yet um okay I'll talk about that watch API too that um that uh was mentioned before so when our operator spins up uh what it does is it connects to the um app platforms API server right this is going to be part of chph F in the open source world and it just issues this thing that says I want to watch everything that matches this label expression it does this syn process at first where it just gets everything and then it gets notified of every update that happens um as long as it's up and running so we take that first set we look at the real world we see if there's any reconciliation work to do and then we hear about every change that ever happens um now I have very few of these operators running in our case it's multi-tenant right like every graphon cloud customer so I've saved resources as a big grafana operator but even just uh running a single one um it's it's great to not have some timer that's sitting there running somewhere let me check all the slos is the timer retrying did it break did it you know doesn't happen I subscribed to the thing and the grafana app SDK uh helps me make sure that that reconciliation Loop is is running properly um so that watch API makes it really easy for us to decouple configuration calls right make me a new SLO from the downstream work um and also makes it easier for me to write more Downstream work later I don't write it in in um um doesn't have to be in a single Loop that's checking things right I can write as many operators as I want they can all watch this resource they can all do different things I can control that right what are the scal of characteristics of my app um I can control what that looks like so for example these are not things we do now but these are things I've been thinking about if if I have prediction models that are trained based on SLO data now something configuration wise has changed I can notify the ml system that it needs to redo some work right um I can uh you know other sorts of things that I might generate asynchronously um for example it might be nice to put um references to all my slos into the right part of Backstage right I have some service definition and backstage people go around look at the catalog who owns what' be great to have links to the slos in backstage right so if I can write an operator that watches slos and syncs into that uh that's another option and there's no reason I have to like bundle that into any particular place uh I have a lot more control in terms of where I run code and and what it learns um and I can watch more than just my app's resources right we're going to be moving more and more core pieces of grafana onto this model um alerting rules dashboards bunch of configuration stuff is going to end up as these sorts of objects and within some context of restricting people's access to your plugins data right it's not going to be a total Wild West free-for-all um you'll be able to watch corant objects and respond to those changes uh one thing for me I might like to watch the grafana summary dashboard and if somebody deleted it just regen it without having to you know Recon right now I still have to do that sort of like poll and reconcile um for those kind of resources I won't have to do that in the future um one more shout out for the graphon app SDK I mentioned the code gen stuff it does it also can scaffold a whole like operator type application for you give you uh some some nice um types so you just provide some functions that that can execute like a Reconciliation Loop you don't write the reconciliation Loop if you use the SDK you just write the what do I do when there's an update what do I do when there's a delete um kind of functions so uh saves a lot of ceremony um you can check it out this is this is open right now if you want to see what the pattern for building these kind of apps looks like obviously graphon itself doesn't Implement all of these yet but this is the SDK that my team uses it's open source you can go see right you could try to generate an operator and get a feel for what's coming from that um you could also sort of fake this by just running your own kubernetes API server and installing resources there and pointing the app SDK to it right like uh that's what I do for local development for example I had just have a kubernetes API server running and I put all this stuff in it so that's how we use this prototype of graan app platform to build the SLO app again I could do this with a pretty small team um and a team that really actually didn't know too much about kubernetes patterns or anything like that and that's because the app platform took a bunch of operational burden off our hands by providing us with storage and authentication stuff um it sort of guided us towards this operator model of reacting to Resource changes it gives us some reliability characteristics we really like for for decoupling work um and it all this schema stuff made it pretty easy for my backend people to talk with my front end people right we share the schema we figure out what the schema looks like together we both get our code I don't write a bunch of Json this and that kind of kind of stuff anymore thanks um we have some time for Q&A I'm excited to answer your questions okay if you have a question for Joe let's see those hands and this auction house rules do apply so if you scratch your nose you've then got to think of a question hello hi I'm Nicholas um company or do you want a company or I'm from vest wind systems name I actually um so for for for reconciliation one challenge that people face in the kubernetes world there is that at the beginning when the operator starts up you need to reconcile the entire world um I've seen elastic they basically have like a high priority queue and a low priority queue do you have are you using something like that internally as well or uh no no we're not we just um we just kind of slowly process the the stuff that comes to us from the Sync API but it's just mostly I think not a scaling problem we've hit yet trying to take the don't write it until you need it sort of approach with this app there's no reason we couldn't do something like that okay will become part of grafana Open Source later the SLO app or is that I unfortunately don't have product road map announcements to be made but obviously we built this on a Clos Source prototype you know we need those features to all be available in grafana OSS before we did any kind of migration y Fair thank you very much any other questions for Joe I'm afraid to can't ask questions if you're up in the higher tiers okay well Joe Blue Bar everybody thanks everyone

