# How to deploy Grafana Beyla on Kubernetes as a sidecar container

Principal Staff Engineer Nikola Grƒçevski demonstrates how to deploy Grafana Beyla on Kubernetes as a sidecar container.

Published on 2024-01-09T16:00:27Z

URL: https://www.youtube.com/watch?v=d7clTdz0bA4

Transcript: so what I have here is some configuration is's a kubernetes cluster but um so I'm going to pull this internet from not even graphon application this is the other developer that works with me on this project Mario masas uh so he's got this uh published some glob blog service that is uninstrumented so this is something random on the internet if you will um and image that we're pulling here and then I'm going to show you so this is not instrumented there's no instrumentation in it so we're going to in the same um provus cluster attach something else which is this grafana baa Auto instrumentation so it's all you got to do so you got to add a another in this case a side car container um we need some privileges because we're going to be touching things inside that are privileged and we finally have to say well this container of baa which is going to instrument something we have to tell it to instrument this um at Port 8443 which is what this service opens up so this go blog application which is a go Application opens up Port 443 and we tell Baya okay well you there's some open Elementary related stuff but we say when you launch look for any service in the system that is has opened this port and once you see it instrument please that's all we do so the rest of the stuff is just for debugging and finally in this system here I have grafana agent I'm going to deploy as well which is configured to send data to uh grafana cloud in this case I'm using mimer for my um metrics and I we use tempo for my traces um so this grafana agent here has a configuration this is very typical how the agent is deployed so in our application here I'm just telling uh Baya to send the events to my local agent and the agent will take care of augmenting those data with anything else on this that it needs and uh eventually send it to um Gana Cloud now we're open source support open Telemetry so you don't have to use the Gana agent if you don't like you can use the open Telemetry collector what your choices are for this third party sources don't have to be grafana products if you don't we hope you will use our products but if you want to push to Prometheus or uh to Jagger or anything else that can support traces you're free to do so right this is just a a demo um and eventually after I've booted everything up into my cluster what I'm going to do is I'm going to run some uh I don't know it's it's a blog post application like a little tool written and go that can you can suppose you can put the various posts so we're going to simulate somebody opening up various pages of this blog and you can see the things um I've set up here to to hit sounds good sounds good all right let's see if we can do this so I've opened three Windows because you need a little bit of uh stuff here so um I'm going to do kind which is uh so I'm going to create a little K cluster here um so wait until that starts up uh so that started all right so what I have here so um into my in this folder is the same thing that I was showing you there what I can't show you is my credentials because I uh to run this demo uh I should be really careful about not to touch that file uh so we have a credentials template in our demo so I'm going to show you that um so we can do something like this and you can see well essentially I I've created a a free account in grafana um where I I'm able to get this end points uh from my Tempo what is my Tempo user I've created a kaana API key um so it give you a template where you can just do this yourself like open a freeron account um get this information and you're set to go once you plug it in that's all you really need to get this demo working so in here I'm just going to do CU c um flyf and so starts with 01 this is my credentials now so I'm not using the template I'm using the ones that I've actually um added and so then I'm going to deploy this agent so so we got gra agent so let's see what's happening here so I'm GNA start k9's over here hopefully with the screen yeah so it's starting so I have a typical kubernetes system here uh and now so far I have my gon agent running we can see it's log nothing special about this um that's as good as it gets so screen like this a little bit so we can see more things um okay so now that I've started the gra agent I'm going to launch I'm going to add the application so this instrumented app so we said this instrumented app application has two containers one is this go blog servers written by Mario and the other one is ba which is going to instrument that service so we can see what's going on here in this kuber system so uh we got the go blog um so Baya is running um sprting various messages and we have the GL blog all right there it is up and running so so far the demo is working um so so port forward so I'm going to forward this port here so what I'm going to do is I'm going to expose this port now to my internal port 8443 for this service the go blog um to my machine so let's try that okay seems to be doing something and I'm gonna open some logs yeah so let's see I'm going to open this so Bay is printing various messages in debug mode so is looking for various executables that launch on my system here it's not important so we're here I'm in the same folder I think yeah so I'm going to learn that low gen that should be k6 and and it's running all this stuff in the background we don't want to watch that so I'm just gonna close that off but maybe Zoom this and now you can see that Baya is tracking various calls that this little program is making at the back right um so we're printing on the screen here uh we can see the gold block service getting all these things uh as a as a load um and at the same time Bay tracking everything that's happening right we track the time it took for each of those requests um and so it's kind of interesting I want to point out so we we have two times over here right so one is this millisecond thing the one is this microsc and I'll get back to that I'll explain a little bit about that as well uh but for now let's just say we're tracking all this requests so now hopefully I can open my screen here I want to switch to grafana to show you how this works so this is my grafana cloud account uh where I have my traces here so here's my Tempo so I open and explore so if I run query maybe not last six hours search let's see run and here we go so in here I see all these events appearing so you notice how like we so we have a specific trace and this Trace I I we have all the events collected we have various attributes picked up by Baya we know that what was the server Port what was the full URL path and then we know that we get it was a get request so now it's interesting you you see this thing that we we did here so for HTTP route we don't have the full eural path um but we have this static with a star so Baya recognizes it has a mode where we automatically recognize paths and reduce the cardinality so that when these metrics get generated in something like Prometheus you don't pay a lot so we try to reduce the cardinality so you don't get a cardinality explosion and make your queries slow and expensive um so if you see over here I talked about this uh timing thing um where we had this two times so Bay is able because he doing this at the level of the the kernel if you will and tracking the go run time we're able to tell when the request actually started for real so it's expect accepting data and it's booting up inside the go run time and we're also able to distinguish that from the time it took to process the request um and why these times are different so whenever you have a go Application uh it internally has his go routines which run every request if you will if every HTTP request now these go routines need a kernel or application thread if you will um to run that on so it takes a bit of time for this request to set up if you are instrumenting just the time your application took inside the go Handler you will see only this time the processing time you don't see this time it took in quue for this request to be served by your application so with baa we can get really much richer information something closer to what the client is experiencing not just the time it took for your Handler to run but how much it took for the go runtime to wake up and actually be able to serve this request so just like I'm having my um uh a view of my traces here I can switch to Prometheus over here see if I can find it yeah and I can just uh I guess I have to select the metric um so we we capture many metrics for example we capture duration seconds and um we can see what that looks like and we see the various routes and as the application is running we know that this particular one which is I guess entry is the slowest one um so all this automatically happened without any intervention on the developer side right there's no particular thing and we reduce the routes to some something that is low cardinality so we really have only five routes where the application was doing a lot more like if we see that script that Mario has has all these things right so we collapse everything that has entry that potentially could cause cardinality explosion under something that's automatically detected it's not a low cality route um and finally this what we produce here is fully compatible with our application of durability so if we go into graphon application observability uh we should be able to after I refresh the page see our GL box service here not yet last five minutes actually remove this let's see refresh and there we go so so we have go blog application here and this is our application zabity plugin tracking all the requests um for any particular rep that we have and so since we capture a little bit of information here this may not actually be the full um output that you would see from manual instrumentation but it does have enough information to go on I think uh be able to see some traces and most of these things will just work for the stuff what doesn't work is the service map and I'll get to that in a second you won't be a see will see some data here um because we don't have that yet but it's coming soon

