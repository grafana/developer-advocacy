# Introduction to Ingesting Logs into Loki with Fluentd and Fluent Bit | Zero to Hero: Loki | Grafana

NOTE: Fluent Bit users This video is out of date we now recommend using the official Loki plugin for Fluent Bit: ...

Published on 2024-07-19T07:00:22Z

URL: https://www.youtube.com/watch?v=s43IBSVyTpQ

Transcript: next on our quest to learn all of the different ways you can ingest logs into Loki we have fluent D and fluent bit are they really indistinguishable like Tweedle D and Tweedle Dum when would you use one over the other when writing logs into ly let's find out fluent D and fluent bit are both open-source data collectors hosted by cncf like other collectors their role is to unify The Collection processing and distribution of telemetry data both were originally designed for handling logs though they have evolved to act as more generalized Telemetry collectors like grafana alloy and The otel Collector since we are talking about Loki we are primarily focused on how they both handle logs so why are there two collectors the answer is down to footprint and performance fluent D grew to become a complex collector with more than 1,000 external plugins and provided reasonable performance fluent bit on the other hand was designed with a much more minimal footprint in mind so it could be deployed on embedded Linux devices it has way fewer plugins than fluent D but this is built by Design although both are still relevant many see fluent bit as the success accessor to fluent D due to the performance gains one of the Core Concepts of both collectors is to structure Telemetry data within a Json format as much as possible the reason behind this is to provide a structured format that unifies all other pipeline stages a pipeline is built using plugins which fall into six categories input passer filter buffer rooting and output now now we aren't going to do a full deep dive into fluent D and fluent bit there are plenty of great videos and content online that will get you through the foundational Concepts in this tutorial we're going to learn how to configure and deploy the Loki Community plugins for both fluent D and fluent bit okay before we continue There is a quick disclaimer both plugins are community supported and open source they are subject to change at the pace that the maintainers wish for them to so certain features from Loki such as structured metadata might not be included yet since these are Community plugins they do have to be installed as third-party plugins in both collectors our recommendation is to use the pre-built containers we host fire our Docker repository which contains the most up-to-date plugins based on the repo's main branch however there are other methods of installation fluent bit has a Helm so you can use that with your kubernetes installations and within fluent D you can also install the Loki plug-in using the fluent gem method with that out of the way let's jump into the tutorial on killer Coda and start configuring both agents to start we'll clone our repository and spin up our observability stack now in your solution you may be using one of the fluent agents or even a combination of both but in this tutorial I'm purely setting up both to show you the difference in configuration we're going to start with fluent D plugins are defined and configured within a configuration file to start We'll add a source called forward this essentially creates a listening endpoint which accepts the forward protocol which is used by fluent D fluent bit and its clients to root messages between one another let's take a quick look at our demo architecture to understand how we are using this plugin the carnivorous Greenhouse is made up of six python Services each service has a custom login class which is implemented based upon the logging style I would like to show in the demo in this case we're using the fluent python client it acts a lot like the otel python client in terms of setup and lets you use the inbuilt pyth logging interface so your code and how you log within your application does not need to change now that being said fluent does have its own metadata called Tags these are primarily used for rooting within the agent this is useful when a particular log needs to go through a specific transformation when others don't in my case I have defined the following tag structure for each service do service name we don't do any creative routing in this demo but you'll see it defined within our configuration so it's worth pointing out okay back to the configuration I have already added this input plugin to your config just so we can stand up an initial configuration of The Collector but you can find the configuration file here next let's move on to our main event the Loki output plugin you can see we begin with our tag rooting we discussed earlier essentially we are telling fluent D to root all records with the parent tag service through this plug-in all child tags are wild carded meaning we'll accept any child of service we then Define our type this is our pre-installed Loki plug-in next we'll Define a static Loki label so we can distinguish between the logs coming from fluent D and from fluent bit and now onto our Dynamic labels this does require one final look back at our architecture diagram within our login class we do Define a slightly custom format which includes two key value pairs you don't get by default when using the fluent clients service and instance ID the one we really care about is Service as we will use this with in grana's new log Explorer to distinguish between our different Services back to the configuration within our labels attribute we can use record access or syntax to extract labels we want in our case these attributes are at the top level so we just specify dollar then the key such as service to extract the tag value at this point we can also rename our labels so I've changed service to service name and left instance ID the same lastly within our configuration we can Define the buffer this helps with rate limiting and how quickly you want logs flushed from the pipeline let's copy these changes to our configuration file once saved we actually need to restart our fluent D container for these changes to be picked up before we configure fluent bits let's skip ahead and deploy our carnivorous Greenhouse application start by generating some logs including some errors and then we can look at the results with in grafana so we can see how our logs have been ingested as you can see within our log Explorer we have six services and if we drill into the logs of our main app service and look at the log attributes we can find our agent service name and instance ID labels now let's jump back and configure FL fluent bit the first thing you'll notice is the format of the config file is quite different to fluent D we still Define plugins but this time we Define the category of plug-in and then the type becomes the name of plugin let's take a look at how to set up the forward plug-in as an example start by defining the category in this case which is input and then the type forward within the name rather than the type the rest most of the configuration attributes are similar to fluent D moving on to our main event then the Loki output plugin in fluent bit there are two plugins the official Loki plugin of fluent bit and then the community designed plugin called grafana D Loki in this case we actually recommend using the community plugin since it has a few more features which improve the flexibility of Loki label definitions again we Define the category first which is output and the name of the plugin as grafana Das Loki rather than just Loki then we Define our match if you watch the fluent d section of the video then this is how we root tags once again we want all records within the parent tag service and we will accept any children under that parent last but not least we Define label map path this is how we Define our Dynamic labels in fluent bit we include a Json file which tells our Loki plug-in how to handle particular attributes of our log record in this case we are mapping the service attribute value to service name and instance ID remains a onetoone mapping like fluent D the fluent bit container requires a restart to accept the configuration changes let's create one final plant in our app and check grafana once again we can now see the label value fluent bit underneath our agent within the Explorer based on the way we have set up this demo the log entry should be equivalent to fluent D though the format might vary and there you have it two more agents ticked off the long list of ingest methods for Loki I'm not going to lie to you choose Ching a collector can feel like a daunting task as there is plenty of options out there each with bonuses and Kinks I hope these videos give you the beginning steps to choose which is right for you the best part is Loki is flexible enough to allow you to swap and change in G methods as your solution evolves so don't feel locked down to one solution next up we're looking at the Loki plug-in for log stash we are also still cooking up our deployment based videos until next time my name is Jay Clifford stay curious

