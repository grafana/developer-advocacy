# How to query Grafana Loki with LogQL

Published on 2025-06-13T15:00:06Z

## Description

In this video, Senior Developer Advocate Nicole van der Hoeven talks about how to query Grafana Loki with LogQL. She talks ...

URL: https://www.youtube.com/watch?v=57dQwcmqkpQ

## Summary

In this video, the presenter discusses how to effectively query logs sent to Loki using its log query language, LogQL. The session is hosted on Grafana Play, where users can experiment with pre-selected queries without needing an account. Key topics include the structure of LogQL, which allows for schema-less querying, the use of pipeline operations for filtering and parsing log data, and the differences between filter, parser, and formatter expressions. The presenter emphasizes the importance of understanding log stream selectors and provides practical examples of constructing queries with various operators. Additionally, viewers are encouraged to explore further resources, including a community call with colleagues Jay Clifford and Sirill Divera, for best practices in writing efficient LogQL queries.

So, you've got your services instrumented and are sending logs to Loki. What's next? All the logs in the world won't help you unless you know how to find meaningful information within them. This means that at some point, you're going to have to learn how to query Loki. 

In this video, I'm going to talk about Log, which is Loki's log query language, and I'll walk you through how to get started with it. But first, let's discuss some alternatives to Log. 

### Exploring Alternatives to Log

Maybe you're unsure about committing to learning a new query language just to query your logs. Your first stop should be to try using logs drill down. Welcome to Grafana Play, which you can find at play.grafana.org. The cool thing about it is that you don't need to sign in at all. You don't need any account or credit card information—it's just a playground for you to try things out.

One of the great features you can explore is under the drill down section, where you can go into logs and see a selection of pre-made queries. This is dependent on the service you have set up. You can access ready-made charts, graphs, and log lines that you can experiment with. This is excellent because you can examine labels and figure out what you're looking for without needing to write any queries from scratch. We've even included graphs for the most common use cases we could think of. This section is constantly evolving, and if you're unsure of what you're looking for and want to explore your data, this is a great place to start—no LogQL required.

### Getting Started with LogQL

If you want to look a bit more closely, you can dive into one of these pre-selected graphs. For example, if you see a detected level label, you can click to select it. If you wish to know the query behind it and maybe edit it a bit, you can click on "explore." This will show you exactly the query that created the graph, allowing you to adjust parameters like the service name or add more conditions. This way, you can build queries without starting entirely from scratch.

Now, let's discuss LogQL. This query language has a few features you should know about:

1. **Schema at Query**: Unlike other databases, Loki doesn't require your data to follow a particular structure or schema. Instead, you can define that schema within your query. Therefore, having various log lines in different formats won't be a problem; you'll determine what to look for in the query itself.

2. **Pipe-Based Syntax**: LogQL is pipe-based, similar to languages like Bash. Log queries often use pipe characters to separate operations. The operation on the left of the pipe passes its result as input to the operation on the right. This allows for a funnel-like filtering process that leads to the specific set of logs you're looking for.

3. **Scalar Vector Support**: Logs can be tricky to aggregate because they're strings. With Loki, you can query for strings in your logs and instruct it to turn those strings into numbers for aggregation. This is useful when you want to get the rate of logs or count the number of instances a specific string appears in a log line.

4. **Filtering and Parsing**: LogQL supports both filtering and parsing. Filtering searches for specific strings in lines and labels, while parsing interprets the line based on a given format and returns elements based on that format. For example, many log lines are in JSON format, and you can search Loki based on these objects.

5. **Formatter Support**: Sometimes, your query’s results might not be in a human-readable format, but that's okay. With LogQL, you can format the way those results display within the query using formatters.

LogQL is also heavily based on PromQL, which is the query language for Prometheus. However, you don't need to know Prometheus or PromQL to write LogQL queries. 

### Running LogQL Queries

LogQL can be executed on Grafana. Right now, this query is being run on Grafana, and I can change and re-execute it directly from there. You can also use the Log CLI, which is a command-line interface specifically for interacting with Loki. It allows you to run queries and retrieve information about previously executed queries.

#### Structure of a LogQL Query

A query always starts with a log stream selector in brackets, and optionally, you can add a pipe followed by a log pipeline. 

- **Log Stream Selector**: Defined in brackets, this is where you specify the labels you want to search on. It helps determine the stream or unique combination of key-value pairs you're looking for.

Let’s return to Grafana Play and go to the logs drill down again. Here, I’ll select "show logs" and navigate to the log section to see all of them. 

When I click on "explore," I can remove the existing query and type a bracket. Just typing the bracket shows all the labels available for selection. For instance, if I want to filter by level, I can select it, say I’m only interested in "error," and run the query. Now, I see results where the level equals "error."

If I want logs from a particular cluster, I can go back to the query, add a comma, and select the cluster label. For example, I might be interested in logs from the EU cluster. After running the query, I now see errors filtered down to this specific cluster. I could further refine this by excluding logs from "EU West" using the "not equal" operator.

### Log Pipeline Expressions

Now, let's talk about the log pipeline, which narrows down the query after defining the log stream selectors. Remember, LogQL parses from left to right. 

#### Types of Expressions:
1. **Filter Expressions**: Used to search for specific strings or ranges of values within the log line or label.
2. **Parser Expressions**: Used for filtering logs in standardized formats like JSON or regular expressions.
3. **Format Expressions**: Change how lines or labels are displayed without altering the underlying data.

For instance, if I’m looking for a specific error message in my logs, I can use the filter expression to find instances that contain a particular string. I can refine my query further by applying parsing expressions for JSON formats or using formatting expressions to display only the necessary fields in the results.

### Conclusion

Those are the basics of constructing a LogQL query. There are actually two types of log queries: log queries and metric queries. Log queries output strings, while metric queries return numbers or vectors of numbers, which we’ll cover in more detail later.

There's much more to explore about LogQL, but this should get you started. If you would like to learn more about best practices for writing queries in Log, check out the Loki community call I did with my colleagues Jay Clifford and Sirill Divera, where we discuss common mistakes, tips for writing performant queries, and more.

Thanks for watching! See you in the next one.

## Raw YouTube Transcript

So, you've got your services instrumented in sending logs to Loki. What's next? All the logs in the world won't help you unless you know how to find meaningful information within them, which means that at some point, you're going to have to learn how to query Loki. In this video, I'm going to talk about Log, which is Loki's log query language, and I'll walk you through how to get started with it. But first, let's talk about some alternatives to Log. Maybe you don't really know if you want to commit to learning a new query language just to be able to query your logs. Well, your first stop I would say would be to try to use logs drill down. Welcome to Graphana Play. This is play.grafana.org. And the cool thing about it is that you don't need to sign in at all. You don't need any account or credit card information or anything. This is well just a playground for you to kind of try things out. And one of the cool things that you can try out is over here under drill down you can go into logs and then you'll already be able to see a bunch of different queries that have been pre-selected for you. Now this is also dependent on the service that you've got. We have a few here that you can choose from. This is really just a place where you can go and already have readymade charts and graphs and also log lines here that you can play around with. This is great because you didn't need to do any of these queries. You can already look at labels. We try to figure out what you're going to be looking for. And then we put graphs for the most common use cases that we could think of in here. This is constantly evolving, but if you're not quite sure what you're looking for and you just kind of want to have a look at your data and play around with it, this is a great place to start. No loql required. And the second step, if you want to look a little more closely, is to go into one of these. Let's say this detected level label, you can click on the select here. There's a bunch of other graphs here. But if you want to know what query this is and maybe just edit it a little bit, you could click here and then click on explore. And now you can see exactly the query that was used to create this graph. So then you can you know change the service name here maybe or add some more conditions here. This is a way to create queries without beginning entirely from scratch. If you already see a dashboard panel that looks sort of like what you had in mind then start with that take the query and then just go from there. Now let's talk about logql. Logery language has a few features that you need to know about. First it enables schema at query. So unlike other databases, Loki doesn't require your data to follow a particular structure or schema. Instead, it kind of lets you define that schema within your query. So it's really okay if you have a lot of different log lines in different formats. Loki is not going to choke on it. You're going to be able to determine what it looks for in the query itself. LogQL is also pipe based. You might be familiar with this from a language like Bash. Log queries are often broken apart by these pipe characters. And what that means is that there's going to be an operation on the left of the pipe. That result from that operation is then going to be passed in as input for the operation to the right of the pipe. And in this way, you kind of get this funnel type filtering for your results. At the end of it is the actual set or subset of logs that you're looking for. Log also has scalar vector support. logs can be kind of tricky to aggregate because they're strings. But with Loki, you can query it for strings in your logs and also instructed to turn those strings into numbers that you can then aggregate. So this is useful for when you want to get the rate of logs or count the number of instances that a certain string appears in a log line. Log supports both filtering and parsing. Filtering is searching lines and labels for a specific string. And parsing means interpreting the line based on a given format and then returning elements based on that. So for example, most of these log lines are in JSON format and you can just click on JSON here and then search Loki based on these objects. Sometimes your query might not return results in a format that is human readable. And that's okay because with logql you can also format the way that those results are displayed within the query itself using formatterers. Log is also heavily based on promql which is the query language for Prometheus. But really you don't need to know either Prometheus or PRMQL to be able to write logql queries. In the rest of this video I'm going to assume you don't know anything about Prometheus or PRMQL. LogQL can be run on Graphana. Right now this query is being executed on graphana and I can change the query and also re-execut it directly from graphana but you can also use log CLI which is a command line interface specifically for interacting with Loki. You can use it to run queries as well as retrieve information about the queries that have already been run onto the structure of a logql query. A query always starts with a logream selector in brackets and then optionally you can add a pipe and then what's called a log pipeline. Let's talk about what that means. The log stream selector which you write in brackets is where you define the labels that you want to search on. So this is also where you can determine the stream or the unique combination of key value pairs that you're particularly looking for in this query. And there are a bunch of operators that you can use. Let's go back to Graphana Play here and then go to logs drill down again. Let's select show logs here and I'm going to go to the log section just so we see them all. Now these are the logs that we want to search for. I'm going to click on explore here just so we get a little query thing here and I'm going to remove that and then I'm going to type a bracket. Just typing the bracket shows all of the labels that are already available for me to select. So, I'm just going down here to choose the one that I want. Let's say I want level. And I hit enter. And then it's telling me what else I can select on. So, I'm going to say I'm only interested really in error. Let's say if I want to, I can already run this. I'm just going to hit shift enter. And these are the results of that query. Now, all that I see here are the ones where level equals error. But what if I only want the ones from a particular cluster? Well, then I can go back to the query here. I can add a comma and I already see a bunch of labels that are available. So, I'll click on cluster. And let's say I'm only interested in EU ones because I'm in the EU. I'm going to hit shift enter. And now filtered the query down even more so that now I'm only seeing errors from this particular cluster. If I wanted to though, I could hide the ones from EU West. So I could put a exclamation point equals. So it's not EU West. So let me run that. And then everything that's here should not be from cluster E west. So this one, for example, is US West, which is great. There are other operators that you can use here other than equals and not equal to. You can play around with regular expressions. So you can say that only the ones that match a a regular expression are going to show up or the ones that don't match a regular expression show up in your results. Now let's talk about the log pipeline which is the optional way to kind of narrow down the query after you define the logream selectors. First we can put a pipe character here. Remember that that the previous log results from this log stream selector will then be used as input for whatever we put afterwards. luuals always parse from the left to the right. So I'm going to talk about three types of expressions that go into the log pipeline and I'm going to be mentioning them in the order from the least expensive computationally to the most expensive. This also means that if you care about how fast your query runs, then you should try to prioritize the expressions in the order that I'm going to tell you. Filters, parsers, and formatterers. First is filter expressions. Filter expressions are used to look for a certain string or range of values within the log line or label. For line filters, the following operators can be used. You can say that you want the log lines to contain a string, not contain a string, or contain or not contain a match to the regular expression that you specify. Let's say in this case that we are particularly looking for this error failed to get keys from memcache. So, I'm just going to copy that and then go up here to the query. I'm going to put an equal sign because what I'm saying here is I want logs that have that have the error level and within this cluster because I'm going to remove the not equals there. And then I want those log lines to contain the phrase the string failed to get keys from memcache. So, shift enter there. And now all of them have that string and are also within that cluster. What if I wanted something that doesn't contain that? Well, then I could just do not equals here. Run that. And now I'm looking at errors that are still within that cluster and are still level equals error, but they no longer have this string. For label filters, I can also use operators like equal sign and not equals for in inequality. Or I can do less than or greater than, less than, equal to, and that sort of thing. So for example, I could put a pipe here and I'll say I'm looking for something from this pod in particular. Now, these are the errors for that specific pod. So if I click into that, sure enough, it's from that particular tempo and you can also use and or or to chain operations for label filters. The second type of expression is parser expressions. Parser expressions are used to easily filter logs that are in a standardized format like JSON, log fmt, regular expressions or unpack. In this new example, the logs are mostly in JSON. So I could do something like you know put a pipe equals here and then copy something specifically. So host and then do that or I can just say you know what I just want this in JSON and then I can interact with the object specifically. So then I'll put another pipe here. Then I'll say that the status should be equal to 200. Now everything that I get will only have the status equals 200. The third type of expressions are called format expressions. Format expressions can be used to change the way that lines or labels are displayed using functions like line format or label format. Format expressions don't change the underlying source data, only the results that are returned by the query. If we go back to this query, you'll see that the results have a lot of information here. But what if we don't need to know all of that information? Maybe we just want some information like maybe the method and let's see the request perhaps. So this URL that was being requested. So we could do we could put a pipeline there and then I'm going to put line format and then have these quotes here and then put these curly braces and that's going to allow us to set the the fields that we want to include. So in this one we want let's say method and then a colon and then let's say we want the request. So basically just these two and nothing else. So I'm going to run that and you'll see that the results now are much more concise. You'll still have the time stamp because that's that's always by default there. Now we can look through it and really understand what's happening without having the entire JSON body there to go through. Those are the basics of constructing a logql query. There are actually two types of log queries both of which follow the same basic structure. Log queries and metric queries. Log queries are queries whose output remain strings structured or otherwise. That's what I showed here. This is a log query. Metric queries return results that are numbers or vectors of numbers, but we'll cover that in the future. There's actually a lot more to cover about logql in general, but that should get you started for now. If you'd like to learn more about best practices for writing queries in Log, then check out this Loki community call that I did with my colleagues Jay Clifford and Sirill Divera, where we go over the top mistakes when writing queries, how to write performant queries, and more. Thanks for watching. See you in the next one.

