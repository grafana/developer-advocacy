# Grafana Beyla July 2024 Community call

Recording of our July's Beyla Community call. We are make a walkthrough for some parts of the code, discussing how to ...

Published on 2024-07-11T08:00:26Z

URL: https://www.youtube.com/watch?v=cOsxqXHWoGQ

Transcript: screen uh yeah recording started okay so I'll share the screen of the issue that I wanted to discuss and uh I think this is the second issue that people have opened related to this um so this is something we recently broke essentially with uh adding service names for the source and destination uh there's a secondary uh this is a second [Music] um uh opened Community issue related to this but essentially people want the IP addresses back okay so I was going to ask you uh with our is this possible to do now with our attribute selection uh Cent we have client address and client name right yes but I think the open Telemetry specification the open tet specification um says we should prefer the name so yeah um as soon as we added the the name resolver essentially uh that took over so we used to report IP addresses um but then the name resolver now says oh I've resolved the name for this service so we're just going to use the name oh yeah uh I see that uh okay I see we have I no sorry I see we have already the client address but only in the traces yes Pro yeah probably it's as simple as adding a client address field to the to the definition of of attributes and enable it yeah that to be simple but I think the open Telemetry specification if I'm not wrong uh doesn't have these as separate Fields anymore uh yeah because it used to but then the new spec has server address and client or peer I forget uh we can take a look maybe I um let me see if I can say yeah and if we go through metrics yeah so so here's the problem and uh let me see if I'll share my new tab sorry so in the in the past there was a separate um there was a separate field like currently we have this server address um this one here here MH um and we have Ser report so there used to be two separate fields in the past that were one was like a net GE something like that um but right now um all we have is the server address and the and it it does say that it it's Bas it should be [Music] um like the name if possible because there is a comment in there with eight if you look to say you should use a name uh because an attacker can potentially use IP and Trigger cardinality limits um so I mean we shouldn't be using the HTTP headers because this could be people can pass in but I think the same thing could be done with addressed but maybe less so but either way there's only one field technically so um well in the past there was a net address so we could Supply it so I don't know if this is a flag we need to add I mean one obvious way would be we could add a flag that would just say uh use uh don't resolve names no or something like um yeah maybe another option is at this client address document it as nonstandard maybe we can prefix it as I don't know baa client address that the same we do with other names uh with metric names and document that it is not a standard I don't know right so come up come up with our own names because I think that the the name of the client is specified somewhere I think it's called Pier um H let me see uh we do have let me see I believe there was one unless that's changed as well uh I I think there was a pier that you could specify uh who called [Music] maybe that's no longer here I see I see some peer addresses but for connections related metrics not for here um H so maybe that's no longer there I think we can report the pier address uh but the question is do we use the name or do we use the the IP and maybe we come up with our own uh unique um field for example like here is server address and we can add a field server IP and there could be a client address or prer address P IP and then and then those are documented by non-standard and if people want to use them instead they can change the attributes and say don't put the exclude the server address but the server IP yeah yeah it's a it's a yeah server IP client IP yeah maybe maybe then explaining these cardinality issues um yeah I mean it will be like if you use client IP a server IP you'll get a card explosion especially if you have a large IP addresses but if people want to do do that by all means right um MH yeah okay that's what I wanted to kind of chat about and see if because it used to be there in the past and we were able to report it but I think it's removed from spans as well oh I think the here um right uh I think the pier is here yeah yes yes but is it h it is in is it in the span okay yeah yeah it's in the span so it's not in the metrics but it's in the span so there's a server address the network Pier address perer address of the network um so maybe that is an issue because we use here we would use the name I'm not sure we should check is this the IP or the name um I don't know what we do here do we switch the name here as well um that might be a bug yeah it does say IP address or unix's domain socket name so I guess here we have to use the IP address um maybe that's another bug we got to look into um but something like this I was thinking maybe we take this field and we make part of the metrics then is then is standard we don't have to use um yeah and we have the network perer Port um so maybe in that case I don't know how we um yeah okay I think we if we need to invent our own name we'll invented yeah we can maybe add some B by do the something like that just to clarify it's our own or just leave it as a common name without any prefix I don't know what the common practice I mean it seems like open toet over here um seem to use Network as a prefix for anything that supposed to be an IP address so I mean that actually makes sense to me like right now server address is the poost identifier okay um so that's server just like metrics they have the server address now over here we have the network P address so maybe we prefix everything that's IP um as with then Network yeah prefix and then that means it's an IP so you'll get a name uh not a name you'll get an IP address so it's the network right so um I like that approach better than what I had initially thought which was an option so this way it fits with our attributes architecture and they can just turn it on yeah okay yeah yeah the that makes sense yeah and the only place when we would always prefer the name would be the um the traces span metric generation because that one is that's what exactly what they do so they use name but for the these the open telary ones we can always switch it yeah yeah makes sense okay cool all right maybe I'll start working on a full request to add this unless you want to take it or some as you prefer I have other tasks in in the background okay okay yeah so I I'll I'll prepare something that standardizes this okay yeah um good stuff yeah I don't think I have anything else to bring up um oh yeah unfortunately not me me neither uh oh oh yeah yeah let me share one moment okay sure yeah is my my screen I lost oh I think I will ah no I I I I lost the screen uh okay uh entire screen okay uh yes uh we need we have a problem in a sech that is that uh the if they open the the destination port in in baa Network metrix the destination Port might be the server Port but will be also the client port for the for the response uh connections and that increases a lot the cardinality so I'm trying to see if if we can taking into account the taking into account the the flags if we can H detect who initiated the the connection and then take the source and destination port and move them to a new uh server which will be the source or the destination depending on on who initiated that uh but I I've I've done some basic tests but it seems this logic is not enough just to say just to check Ingress or ESS so probably we need to to add another another flag to or to check other flags or or add another field just to check the initiator of the of the of the task this is what Derek add it right dark um yeah and also internally uh internally in in in baa with the ass team okay yeah because this is the Community member out of this uh approach where we're looking up the flow directions and if it's only null that's when we set it so the Hope was that the First Communication we see um I wonder if the ID is wrong then what's the id there because this this ID you mean what's your ID uh let me see id id uh ID so how is that constructed what's in the ID it's set to zero then from the ethernet heater what's in the structure flow ID can you control click on the flow ID yeah thing you have the source and destination IPS the protocol the source and destination ports and these this should be actually okay so I think I know what the issue is um right so the problem with the current code um is that it does check the initiating connection but it doesn't sort the IP addresses uh so hear me out like that table that map is the right map so he added a map dark out of the map but I missed this so the flow ID when it's initiated it will have Source IP destination IP and it will have a source boort destination point but and it's the correct place where we check the flags and we say okay the flags are now starting this connection but when we receive the data back we will not match because it's going to be reversed it's backwards yes the source I it's the same connection but it's backwards so it will not matching the table so we do this in application observability all over the place where uh every connection that we try to match on to see if like for example you know application observability this is important for us too because we go um Source IP destination IP Source Port destination Port outgoing we start the request and the other server responds and then we need to match that with the start but when we come back when they send us back the data the ports and the IP addresses are reversed they're backwards M yeah so we can't match them which is why Yeah we actually we have two IDs for the One Direction flow the Ingress flow and another for exactly so yeah so this table that he added where we look up the direction and we say that's something he added uh Derek um so we we can use the helper or write a similar one that we use in the application observability to sort as the the flow ID when it's added to the initial Direction table and then you'll be able to kind of keep the direction correct all the time so right now when you go back it's reversed because then and every like essentially there's two directions all the time so you're saying okay this direction was one but if you want to have the originating direction to know which one was the server Port um for that uh you need um you need to sort that data structure the sour Source IP addresses so that we could when you hit the table it will give you the original Direction which I think what the intent was we didn't all want to find the direction of the communication in both ways we know that already uh we wanted to find out was this a client request or was this a server request and okay that's what the direction meant client or server and if you look in the flow monitor right now uh I think that's the intent of the code the code you were showing before with the direction if you see what's happening you scroll down uh yeah scroll down more more more here right where's the direction where's yeah so we look up the flow directions with this ID and if we don't find it we check to see if it's a or sin flag and then we set the direction um so then we write to the map so next time this particular flow happens we know exactly what Direction was but um if we sort it we will always know so maybe it's another flag but what I mean is that um if you have it sorted then on the client when it's outgoing you will see the sin act flag so you know it's you'll see the sin flag then you know it's like erress ah ah okay right understand then you always know forever and once you sort it and store it it will be oh this was initiated for the purpose of a client and then you know which one is the Ser report it's the destination Port yeah but when it's received when it's syac when we're acknowledging a connection that's on the server side then it's Ingress then once you sort it you that's initially set and that's it for this connection so all I think we need to do is write a sord Helper and then this flow directions map can be using the sorted ID you know what I mean okay yeah yeah and then we can use the original ID but we also have the sorted ID and we can always tell whether this was a client or a server I see I see that's the exact approach we use for um um that's exact approach we use for finding the server port in application observability um so I'll show you the difficulty we have there so if you open HTP sock um yeah maybe look for TCP send TCP send search for DCP send yeah uh yeah here is an example right this one okay yeah yeah so if you see what's happening is we parse the sock info a line 290 right uh 290 line 290 um further down we parse it m and then we remember the original destination Port then we sort the connection info and then the final sort of connection information is like the sorted plus we keep track of this original Port so we know which way was it going because all the internal matching of outgoing and responses they all use the sorted there's no other way to match it but at the end when we create the event we need to say oh this is a client call so we need to know then since everywhere in the code we track the sorted connection we don't care about the unsorted but at the end the very last time when we are about to send the event to create for user space we need to know if this was a client or a server and then we use the the original dport the original destination port to know oh did we swap it and on their first time we saw this message was it swapped so then we used that to say okay the real destination Port was this we used to have a very simple logic that simply said the bigger Port is the client Port right but then I had to add all this tracking because the open Telemetry demo was uh is using a large port in the ephemeral range for the grpc of one of the services and it broke everything I think it was one of the services I think it was the not new flag D but I think the original Flags feature flag service was using this crazy large port for grpc yeah um so this flow directions will help you um this is the exactly the only reason we have this flow Direction and it's now if you look it's on the flow metric it's not added to each individual flow right I think we have you know what I mean yeah I see I see together with the flux yeah together with the flags that's why he moved it to there but I think what we need to do is use a sorted ID just like we sort in HTTP sock and then it will work I think you'll always know um which one to pick because if the direction was client or erress then you know which one is the server Port if the direction was Ingress then you also know which one is the ser report uh but right now it's inconsistent because your response it would be it will some of them will have everyone is duplicated now yeah okay M okay because the map doesn't match like on the we essentially have two right on the response the first response that we yet will record a practically new flow Direction M MH yeah but then if we sort the addresses yeah H shall we also sort the ports I guess yes yes yeah then it will happen that either Ingress or ESS flows uh will match into the same key because now the the direction is is in the metrix not in the key ah then we will duplicate codee and and I we'll duplicate metrics or traffic I mean the numbers the values and I don't know if we can distinguish 10 no but so if we make you can actually keep this direction flag but what you can do is add originating Direction all you know is that when this request happened was this uh a client or a server request and then because you reive a response like eventually like server a initiated a client request to server B who's now getting a server request and then then we'll record two sort of flows we'll see a client flow from A to B and we'll see a server flow from A to B uh and these flags will correctly set the direction um but then when you respond from server B to server a the server a will receive the response with reversed client import I think yeah that will be backwards it will look as if the The Source Port will be the server port and your destination would be the ephemeral um yeah I don't know like so this direction right now we don't use for anything right do we use it no no I think it's a hidden field most I I I think it's a it's a visible attribute just in case someone wants to see in their metrix but I don't think we use it for any other logic yeah so if we want to repurpose it to be whether this was a server or a client call so you can tell the port I think um oh maybe it needs to be the key needs to be what about the flags yeah actually the flags are also there I think we can at some point use them Yeah well yeah there is one problem though with what I'm proposing so if we sort the IP addresses uh how can we tell that this is on two different machines two different hostes yeah yeah we can't tell them apart we can't tell them apart right so what I mean is that uh if we sort them there will be so I guess in that case direction would be the originating direction or the first Direction um so this was a client request so you always know um that it was the client but that that's what you need actually don't you H you mean only the direction yeah I mean you just need a reliable way to tell which was the server Port right yes uh I tried using the direction uh but ER in in that case it didn't work always because let me think in an sample uh the response the response will have a separate flow the response will get a new flow and we will not know what the direction was and then when we don't know what it is we we fall back to sort and then we say whichever is the biggest but I think if you sort the IP addresses and ports just like we sort in application observability you will not have a problem it would always be you will be able to tell based on the direction which one was your Ser report always okay I would try then yeah if you sort it it' definitely be correct but um because all it does here is start to figure out what was the original Direction that's all so right now direction if we set the meaning of direction to be the First Communication will because a client call or a server call that's that's the only um I think that will work um then you'll be able to tell always what the what the port is okay okay I'll give a I'll give a shot tomorrow MH yeah um yeah that's right yeah uh because right and if we ever need uh the actual Direction maybe you can make this like a flag client or server that that you like maybe you need another flag but if nobody uses Direction right now let's just use direction for that purpose because um I mean I don't know if we need to ever know if this was Ingress or egress as a network bites um I don't know yeah yeah yeah yeah I think we can we can just repurpose the field yeah I think the intention was that it's the originating Direction the reason for this communication was a client from this IP address sent yes server request to decide our IP address and um we can always tell the originating Direction um the other the other approach is maybe that won't be enough because you will yeah all right actually it's it's more complicated that what I suggest won't work so I think you um because on the what is it this going to tell you like in the if we sort them and we know the origin direction is um is client then no I don't think it will work mhm see that ch is that um if the originating request was a client and we sort the connections when we receive the the flow on the server we have no way of knowing this was a server call now right um I guess there are some for for okay no the ACT is for the server yeah I don't know if there are other flat might so the ACT is for the server MH um but in memory this flow map flow directions uh would [Music] be ah yeah you're right because uh from the client side if it's inen another host it won't see any it won't see any flag so it it will be it won't be able to to know it because baaya is only one B monitoring both the client and the server so if we sort the connection for the client because that's the the first Direction it was erress then when he gets to the server we will look it up and they will find the same sorted IP destination pair and we'll say oh okay so that's we know the direction is client but right now we're processing a server call um so because it's a server call this is only invoked once right or not yeah I mean when the key does not exist in in the map right but the key that's I'm saying the key will not exist in the map yeah on the client we will store it right so let's say the client sends one packet we will store it the flow ID Direction in a map then the server receives the packet it would store a new flow Direction in the map saying I'm a server call so far so good that's what we want to happen because then we can tell the ports but the problem is now the server is going to send the response back and I think in that case the destination Source IP addresses will be reversed yeah so then it will find the flow direction to be on the original client yeah oh but maybe that's what you need actually don't actually that actually works actually hold on a second um that actually does work um so if the direction was Ingress you should looking at the server Port is the source part yeah but uh yeah yes because Ingress maybe I did something wrong uh because Ingress should not be actually who initiated but if it's a flow you receive or you so even a response might be Ingress for the client right and and a request will be Ingress for the server so that's why this uh we need I I guess we will need some extra Flags there or some extra information yeah no but I'm surprised it doesn't work um so this is what I what [Music] I I think it might actually if you um can I share my screen for a second I'll open the same file yes sure sure sure sure okay so wrong window um who else okay so I think maybe it will work so if we go here and see what this logic is doing um I'm just going to create something like this so let's see we have ip1 and it's going to have 1 2 3 4 5 let's see it's doing sin flag right to ip2 uh 8080 let's just say right M this is the first Direction This is ESS okay so after this happens uh the server side um we have received it and what we will see um The Source IP so the question is here what do we see this is going to be the indress call and I think what we'll uh see would [Music] be uh ip2 8080 um ip1 something like this um s flag ip1 2 three four five okay this is this is from AA running at the client site right no we're monitoring both processes let's say we're monitoring both we're monitoring both the server and the client okay okay no but what I mean is that uh for example uh ah okay SE agress okay but I mean that this same flow I guess the server port for example a PO would receive that by its Ingress ah no because now now we don't use the interface as sress but the but the flags okay okay okay right right so so so this will create this um will create P1 into the map which is going to be ip1 1 2 3 4 five and then it will be ip2 8080 so that's so this will create a key1 and then this one here we'll create ke2 ip2 a 880 ip1 1 2 3 4 5 yeah okay so so far I think so good these two will match uh there will be two separate Keys um so then further down here happens something and now this is sending back but now the IP is are revers so it will be ip1 so this is response ip1 um 1 two 3 four five um no Flags who cares what the flags are ip2 um some Flags I don't know right ip2 will be 8080 now this is going to be egress from the server right mhm so this is ingress server and this is uh ESS client something like this now yeah this will find key1 key1 IP 1 1 2 3 4 5 and ip2 88 so you will find the originating key you will find this guy because now in Bay's memory this will be in the opposite order for the response so this guy will find key1 and then eventually after a bit we get to on the client we see um ip2 8080 is responding to me um Flags we don't know or we don't care and it will be ip1 1 2 3 4 5 client and this is ingress now Ingress on the client right so then this guy will match P2 ip2 8080 ip1 2 3 four five so Tech technically if you look that two Ingress calls have the same key the two ESS calls have the same yeah yeah but check that one one ESS belongs to the client and another ESS belongs to the the server and same for the ingresses right so they're reverse right however if you make your logic to say if we told this was egress with then we have the same pair so we have to look at the second Port if it's Ingress doesn't matter if it's a server or client we know look at this port yes exactly so technically by what we have today if direction is ingress you look at one port if the direction is egress you look at the other Port okay then I did something wrong with my test because this is exactly what I'm doing but there might be one one case where this doesn't work one case where this doesn't work is this doesn't exist let's say you just have a client call and you're not monitoring the server now what you're going to end up with it's two different Keys yeah right you're gonna get two different keys and so there's nobody to save this flag there's nobody's going to save this key too so okay you're you're in the dark so nobody's going to put this in the map okay so let's say this doesn't exist so then you're going to get key one and you have the port then you're going to get key2 so what this code will do will say well we don't know the direction so we're going to look at the source and destination port and if the whichever is bigger we're going to make it erress so when this comes it will flip it essentially but it doesn't flip the ports it's gonna so it doesn't flip the force but it's going to say this is not Ingress this is going to be because technically Source Port actually it might work if it sours it unless the ports are in the Emeral range because check what happens like if it if it did that then Source IP will not be actually bigger than for key2 will not be bigger than the destination Port so it will say this is ingress and it will be exactly correct so the way I see this could break is only if the the direction is um if they use a feral port for the server then okay yeah I'm not I'm not sure so if they use a femal port for the server everything's fine if we track both processes but if we don't track one of them if we can't track one of them then this will come back reversed okay and then you have no idea yeah but then then that could fail if the because we we don't actually track processes we track the network stock exactly that will fail if the server is in a different host 100% yeah if the server is a different host uh then you have two different Maps so you won't be able to do it but this is why we have this Saving Grace yeah yeah that tries to check this however if they used like grpc some really large Port this check is flawed right because it would say this is bigger than that therefore it's whatever so the only way I see around this if you want to make this more reliable is to have a sorted version of this and then you match on the sorted version and you say well this was originating client um then you know what the direction was because technically if we sorted this right if we made it sorted um let's say the the second scenario is this doesn't actually um this becomes sorted so we'll have the initial happening and let's say we keep the Sorting with bigger Source port so this becomes eager's client then it's key1 right then it comes here we sorted so now we're going to flip this it comes as this but we don't store the key uh we're going to sort and we're going to make it ip1 one two 3 4 five sinac flag ip2 8080 okay and then we say oh but we found the key and we're going to say well this is egress okay yeah okay and this ESS and then we're going to make key1 IP 1 1 two 3 four five ip2 8080 okay now it's outgoing again we won't in this case we'll sort but it ends up being the same result larger okay now if we come back here again this will receive it but then we won't do this we will sort it again we'll make it ip1 uh 1 two three four five who cares about the flags right and then we go ip2 8080 erress right so we'll do this because will find the key will be identical okay I see I see so so then the only problem is that the ESS does not actually mean egress anymore all it means is that was the initial connection client or server yeah but in that case the ESS or Ingress is is stored in the metrics Associated to that key yeah so now we cannot have for the same key we cannot have both Ingress and ESS ESS Matrix right but I think we that's what I'm saying we will not sort the the actual IP addresses here for the flows the only thing we will sort is this map flow directions which is only used to tell what was the initi okay okay okay okay okay you see what I mean so we will only use we only use sorted key here okay okay yeah I see and then right and then so all that really means is that the first connection that Baya saw for these two hosts was that a client or a server that direction will not mean the direction of the flow of the current flow okay it would mean actual the initial initiator initial the initial flow so that's why I'm saying you want to keep a separate flag for that or do you want to keep we canose this yeah we can I will see I will see yeah maybe the the the one that uses the less memory will be better better right if we don't use direction for anything just rename this to initiating direction or something yes and and so in in case there is no let's say we don't see any of this this was all like dark for us we did not monitor this we didn't something happened it will still work because with sorting either way you'll find it yeah I see I see you don't see the server it's not instrument it's maybe going somewhere in the in AWS cloud or whatever yeah it doesn't matter when it comes back you'll still sort it and you'll find the initiating Direction and you'll say okay well I know which one's my for okay mhm and and the opposite works too so if let's say that's one situation let's say the other situation it's a client from outside yeah and you only see a server which means you don't see this yeah H Nica I'm sorry but I I need to I need to leave okay okay we can continue talking tomorrow because I think it's very very very very illustrating yeah okay okay sounds good but yeah absolutely and I think if you sort them for this collection you're good okay okay I think it will work but it will not mean what it means right now it will not mean Direction it would mean initiating Direction initiator yeah okay yeah great all right cool okay thank you very much for for your help yeah of course yeah thank you byebye

